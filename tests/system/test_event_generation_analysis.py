"""
Unit tests to analyze and measure event generation patterns during FFTT initialization.

These tests serve as baseline measurements and verification tools for optimization efforts.
"""
import asyncio
import logging
import pytest
import threading
import time
from collections import defaultdict, Counter
from typing import Dict, List, Any
from unittest.mock import AsyncMock, MagicMock, patch

from resources.events import EventQueue, ResourceEventTypes
from resources.managers.coordinator import ResourceCoordinator
from resources.monitoring.circuit_breakers import CircuitBreakerRegistry
from resources.state import StateManager
from resources.managers import AgentContextManager, CacheManager, MetricsManager
from resources.monitoring import MemoryMonitor, HealthTracker, SystemMonitor
from run_phase_one import PhaseOneApp


class EventCountingQueue(EventQueue):
    """EventQueue subclass that counts events by type for analysis."""
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.event_counts = Counter()
        self.event_timeline = []
        self.start_time = time.time()
        
    async def emit(self, event_type: str, data: Dict[str, Any], 
                   correlation_id: str = None, priority: str = "normal") -> bool:
        # Record event for analysis
        self.event_counts[event_type] += 1
        self.event_timeline.append({
            'timestamp': time.time() - self.start_time,
            'event_type': event_type,
            'priority': priority,
            'data_size': len(str(data)) if data else 0
        })
        
        # Call parent implementation
        return await super().emit(event_type, data, correlation_id, priority)


class ComponentCreationTracker:
    """Tracks component instantiation to identify duplicate creations."""
    
    def __init__(self):
        self.instances = defaultdict(list)
        self.creation_timeline = []
        
    def track_creation(self, component_name: str, instance_id: str, thread_id: int):
        self.instances[component_name].append({
            'instance_id': instance_id,
            'thread_id': thread_id,
            'timestamp': time.time()
        })
        self.creation_timeline.append({
            'component': component_name,
            'instance_id': instance_id,
            'thread_id': thread_id,
            'timestamp': time.time()
        })
        
    def get_duplicate_instances(self) -> Dict[str, int]:
        """Returns components that were instantiated multiple times."""
        return {name: len(instances) 
                for name, instances in self.instances.items() 
                if len(instances) > 1}


@pytest.mark.asyncio
class TestEventGenerationBaseline:
    """Baseline measurements of event generation during system initialization."""
    
    async def test_measure_event_queue_initialization_events(self):
        """Measure events generated just by creating and starting an EventQueue."""
        event_queue = EventCountingQueue(queue_id="test_baseline")
        
        # Start the queue
        await event_queue.start()
        
        # Wait for initial processing
        await asyncio.sleep(0.5)
        
        # Stop and analyze
        await event_queue.stop()
        
        print(f"\n=== EventQueue Baseline ===")
        print(f"Total events: {sum(event_queue.event_counts.values())}")
        print(f"Event types: {len(event_queue.event_counts)}")
        print(f"Top event types:")
        for event_type, count in event_queue.event_counts.most_common(5):
            print(f"  {event_type}: {count}")
            
        # Assertions for baseline
        assert sum(event_queue.event_counts.values()) < 10, "EventQueue baseline should generate < 10 events"
        
    async def test_measure_circuit_breaker_registry_events(self):
        """Measure events generated by CircuitBreakerRegistry initialization."""
        event_queue = EventCountingQueue(queue_id="test_circuit_baseline")
        await event_queue.start()
        
        # Create circuit breaker registry
        registry = CircuitBreakerRegistry(event_queue)
        
        # Create a few circuit breakers to see the pattern
        for i in range(5):
            await registry.get_or_create_circuit_breaker(f"test_circuit_{i}")
            
        # Process pending operations
        await registry.flush_creation_queue()
        await asyncio.sleep(0.5)
        
        await event_queue.stop()
        
        print(f"\n=== CircuitBreakerRegistry Events (5 circuits) ===")
        print(f"Total events: {sum(event_queue.event_counts.values())}")
        print(f"Events per circuit: {sum(event_queue.event_counts.values()) / 5:.1f}")
        print(f"Top event types:")
        for event_type, count in event_queue.event_counts.most_common(5):
            print(f"  {event_type}: {count}")
            
        # Calculate expected scaling to 112 circuits
        events_per_circuit = sum(event_queue.event_counts.values()) / 5
        projected_112_circuits = events_per_circuit * 112
        print(f"Projected events for 112 circuits: {projected_112_circuits:.0f}")
        
    async def test_measure_resource_coordinator_events(self):
        """Measure events generated by ResourceCoordinator initialization."""
        event_queue = EventCountingQueue(queue_id="test_coordinator")
        await event_queue.start()
        
        # Create ResourceCoordinator
        coordinator = ResourceCoordinator(event_queue)
        
        # Register basic managers
        state_manager = StateManager(event_queue)
        context_manager = AgentContextManager(event_queue)
        cache_manager = CacheManager(event_queue)
        
        coordinator.register_manager("state_manager", state_manager)
        coordinator.register_manager("context_manager", context_manager, ["state_manager"])
        coordinator.register_manager("cache_manager", cache_manager, ["state_manager"])
        
        # Initialize all
        await coordinator.initialize_all()
        await asyncio.sleep(0.5)
        
        await event_queue.stop()
        
        print(f"\n=== ResourceCoordinator Events (3 managers) ===")
        print(f"Total events: {sum(event_queue.event_counts.values())}")
        print(f"Events per manager: {sum(event_queue.event_counts.values()) / 3:.1f}")
        print(f"Top event types:")
        for event_type, count in event_queue.event_counts.most_common(10):
            print(f"  {event_type}: {count}")
            
    async def test_measure_monitoring_system_events(self):
        """Measure events generated by monitoring system components."""
        event_queue = EventCountingQueue(queue_id="test_monitoring")
        await event_queue.start()
        
        # Create monitoring components
        memory_monitor = MemoryMonitor(event_queue)
        health_tracker = HealthTracker(event_queue) 
        system_monitor = SystemMonitor(event_queue, memory_monitor, health_tracker)
        
        # Start monitoring
        await memory_monitor.start()
        await health_tracker.start()
        await system_monitor.start()
        
        # Let them run briefly
        await asyncio.sleep(1.0)
        
        # Stop monitoring
        await system_monitor.stop()
        await health_tracker.stop()
        await memory_monitor.stop()
        await event_queue.stop()
        
        print(f"\n=== Monitoring System Events (1 second) ===")
        print(f"Total events: {sum(event_queue.event_counts.values())}")
        print(f"Top event types:")
        for event_type, count in event_queue.event_counts.most_common(10):
            print(f"  {event_type}: {count}")


@pytest.mark.asyncio            
class TestSingletonBehavior:
    """Test singleton patterns to identify duplicate instantiations."""
    
    def test_circuit_breaker_registry_singleton(self):
        """Verify CircuitBreakerRegistry maintains singleton behavior."""
        event_queue1 = EventQueue(queue_id="test1")
        event_queue2 = EventQueue(queue_id="test2")
        
        # Create two registries with different parameters
        registry1 = CircuitBreakerRegistry(event_queue1)
        registry2 = CircuitBreakerRegistry(event_queue2)
        
        # Should be the same instance
        assert registry1 is registry2, "CircuitBreakerRegistry should be singleton"
        
        # Check if event_queue was updated
        print(f"Registry1 event_queue: {id(registry1._event_queue)}")
        print(f"Registry2 event_queue: {id(registry2._event_queue)}")
        print(f"Event_queue1: {id(event_queue1)}")
        print(f"Event_queue2: {id(event_queue2)}")
        
    def test_resource_coordinator_singleton(self):
        """Verify ResourceCoordinator maintains singleton behavior."""
        event_queue1 = EventQueue(queue_id="test1")
        event_queue2 = EventQueue(queue_id="test2")
        
        # Create two coordinators
        coord1 = ResourceCoordinator(event_queue1)
        coord2 = ResourceCoordinator(event_queue2)
        
        # Should be the same instance
        assert coord1 is coord2, "ResourceCoordinator should be singleton"
        
        print(f"Coord1 event_queue: {id(coord1.event_queue)}")
        print(f"Coord2 event_queue: {id(coord2.event_queue)}")


@pytest.mark.asyncio
class TestEventCascades:
    """Test for event cascades that might cause exponential event generation."""
    
    async def test_circuit_breaker_state_change_cascade(self):
        """Test if circuit breaker state changes cause event cascades."""
        event_queue = EventCountingQueue(queue_id="test_cascade")
        await event_queue.start()
        
        # Create registry with a few circuit breakers
        registry = CircuitBreakerRegistry(event_queue)
        
        # Create parent and child circuit breakers
        parent_circuit = await registry.get_or_create_circuit_breaker("parent_circuit")
        child_circuit = await registry.get_or_create_circuit_breaker("child_circuit")
        
        # Set up dependency
        await registry.register_dependency("child_circuit", "parent_circuit")
        
        # Clear existing events
        event_queue.event_counts.clear()
        
        # Trip the parent circuit (should cascade to child)
        await parent_circuit.trip("Test cascade")
        
        # Wait for cascade to complete
        await asyncio.sleep(0.5)
        
        await event_queue.stop()
        
        print(f"\n=== Circuit Breaker Cascade Events ===")
        print(f"Total events from single trip: {sum(event_queue.event_counts.values())}")
        print(f"Event breakdown:")
        for event_type, count in event_queue.event_counts.most_common():
            print(f"  {event_type}: {count}")
            
        # Should be a reasonable number of events, not exponential
        assert sum(event_queue.event_counts.values()) < 20, "Circuit breaker cascade should not generate excessive events"
        
    async def test_agent_initialization_cascade(self):
        """Test if agent initialization causes event cascades."""
        event_queue = EventCountingQueue(queue_id="test_agent_cascade")
        await event_queue.start()
        
        # Import agent classes
        from phase_one.agents.garden_planner import GardenPlannerAgent
        
        # Create supporting managers
        state_manager = StateManager(event_queue)
        context_manager = AgentContextManager(event_queue)
        cache_manager = CacheManager(event_queue)
        metrics_manager = MetricsManager(event_queue)
        memory_monitor = MemoryMonitor(event_queue)
        health_tracker = HealthTracker(event_queue)
        
        # Clear initial events
        await asyncio.sleep(0.2)
        event_queue.event_counts.clear()
        
        # Create agent
        agent = GardenPlannerAgent(
            "test_garden_planner",
            event_queue,
            state_manager,
            context_manager,
            cache_manager,
            metrics_manager,
            None,  # error_handler
            memory_monitor,
            health_tracker
        )
        
        # Wait for initialization events
        await asyncio.sleep(0.5)
        
        await event_queue.stop()
        
        print(f"\n=== Agent Initialization Events ===")
        print(f"Total events from agent creation: {sum(event_queue.event_counts.values())}")
        print(f"Event breakdown:")
        for event_type, count in event_queue.event_counts.most_common():
            print(f"  {event_type}: {count}")


@pytest.mark.asyncio
class TestFullSystemEventGeneration:
    """Test event generation during full system initialization (like the original issue)."""
    
    @pytest.mark.slow
    async def test_phase_one_app_event_generation(self):
        """Measure events during PhaseOneApp initialization (the main culprit)."""
        
        # This test replicates the conditions from run_phase_one.py that generate 280+ events
        
        # We'll mock the Qt components to avoid GUI dependencies
        with patch('PyQt6.QtWidgets.QApplication'):
            with patch('display.ForestDisplay'):
                
                event_queue = EventCountingQueue(queue_id="test_full_system")
                
                # Create app components manually to measure each step
                print("\n=== Phase One App Event Generation Analysis ===")
                
                # Step 1: Event queue
                await event_queue.start()
                step1_events = sum(event_queue.event_counts.values())
                print(f"After EventQueue start: {step1_events} events")
                
                # Step 2: Circuit breaker registry  
                circuit_registry = CircuitBreakerRegistry(event_queue)
                await asyncio.sleep(0.1)
                step2_events = sum(event_queue.event_counts.values())
                print(f"After CircuitBreakerRegistry: {step2_events} events (+{step2_events - step1_events})")
                
                # Step 3: Resource coordinator
                resource_coordinator = ResourceCoordinator(event_queue)
                await asyncio.sleep(0.1)
                step3_events = sum(event_queue.event_counts.values())
                print(f"After ResourceCoordinator: {step3_events} events (+{step3_events - step2_events})")
                
                # Step 4: Core managers
                managers = [
                    ("state_manager", StateManager(event_queue), []),
                    ("context_manager", AgentContextManager(event_queue), ["state_manager"]),
                    ("cache_manager", CacheManager(event_queue), ["state_manager"]),
                    ("metrics_manager", MetricsManager(event_queue), ["state_manager"]),
                    ("memory_monitor", MemoryMonitor(event_queue), []),
                    ("health_tracker", HealthTracker(event_queue), []),
                ]
                
                for name, manager, deps in managers:
                    resource_coordinator.register_manager(name, manager, dependencies=deps)
                    
                await asyncio.sleep(0.1)
                step4_events = sum(event_queue.event_counts.values())
                print(f"After registering managers: {step4_events} events (+{step4_events - step3_events})")
                
                # Step 5: Initialize all
                await resource_coordinator.initialize_all()
                await asyncio.sleep(0.2)
                step5_events = sum(event_queue.event_counts.values())
                print(f"After initialize_all: {step5_events} events (+{step5_events - step4_events})")
                
                # Step 6: Create monitoring
                system_monitor = SystemMonitor(
                    event_queue, 
                    resource_coordinator.get_manager("memory_monitor"),
                    resource_coordinator.get_manager("health_tracker")
                )
                await system_monitor.start()
                await asyncio.sleep(0.2)
                step6_events = sum(event_queue.event_counts.values())
                print(f"After SystemMonitor start: {step6_events} events (+{step6_events - step5_events})")
                
                # Final analysis
                print(f"\nFinal event count: {sum(event_queue.event_counts.values())}")
                print(f"\nTop 15 event types:")
                for event_type, count in event_queue.event_counts.most_common(15):
                    print(f"  {event_type}: {count}")
                    
                # Cleanup
                await system_monitor.stop()
                await resource_coordinator.shutdown()
                await event_queue.stop()
                
                # Verify the issue exists
                total_events = sum(event_queue.event_counts.values())
                print(f"\nTotal events generated: {total_events}")
                
                # This should fail initially, confirming the problem
                # After fixes, this threshold should pass
                assert total_events < 50, f"System should generate <50 events during init, got {total_events}"


if __name__ == "__main__":
    # Run the tests individually for detailed analysis
    import sys
    
    async def run_analysis():
        test_instance = TestEventGenerationBaseline()
        
        print("=== FFTT Event Generation Analysis ===\n")
        
        try:
            await test_instance.test_measure_event_queue_initialization_events()
        except Exception as e:
            print(f"EventQueue test failed: {e}")
            
        try:
            await test_instance.test_measure_circuit_breaker_registry_events()
        except Exception as e:
            print(f"CircuitBreaker test failed: {e}")
            
        try:
            await test_instance.test_measure_resource_coordinator_events()
        except Exception as e:
            print(f"ResourceCoordinator test failed: {e}")
            
        try:
            await test_instance.test_measure_monitoring_system_events()
        except Exception as e:
            print(f"Monitoring test failed: {e}")
            
        # Run singleton tests
        singleton_tests = TestSingletonBehavior()
        try:
            singleton_tests.test_circuit_breaker_registry_singleton()
        except Exception as e:
            print(f"CircuitBreaker singleton test failed: {e}")
            
        try:
            singleton_tests.test_resource_coordinator_singleton()
        except Exception as e:
            print(f"ResourceCoordinator singleton test failed: {e}")
            
        # Run cascade tests
        cascade_tests = TestEventCascades()
        try:
            await cascade_tests.test_circuit_breaker_state_change_cascade()
        except Exception as e:
            print(f"Circuit breaker cascade test failed: {e}")
            
        print("\n=== Analysis Complete ===")
        
    if len(sys.argv) > 1 and sys.argv[1] == "full":
        # Run the full system test
        asyncio.run(TestFullSystemEventGeneration().test_phase_one_app_event_generation())
    else:
        asyncio.run(run_analysis())